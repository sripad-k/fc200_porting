/******[Configuration Header]*****************************************//**
\file
\brief
  Module Title : Coverage Measurement

  Abstract : Module to provide capability to measure statement coverage

  Software Structure : SDD References: N/A

*************************************************************************/

/***** Includes *********************************************************/

#include <string.h>
#include "soc/defines/d_common_types.h"
#include "soc/defines/d_common_status.h"
#include "sru/ethernet/d_eth_interface.h"
#include "soc/timer/d_timer.h"
#include "kernel/error_handler/d_error_handler.h"
#include <malloc.h>
#include <errno.h>
#include "d_coverage.h"

/***** Constants ********************************************************/

#define GCOV_COUNTERS        9

#define GCOV_TAG_FUNCTION_LENGTH  3
#define GCOV_DATA_MAGIC   ((Uint32_t) 0x67636461)
#define GCOV_TAG_FUNCTION ((Uint32_t) 0x01000000)
#define GCOV_TAG_COUNTER_BASE ((Uint32_t) 0x01a10000)
#define GCOV_TAG_FOR_COUNTER(count)         \
(GCOV_TAG_COUNTER_BASE + ((Uint32_t) (count) << 17u))

#define BUFFER_SIZE   65536u

/***** Type Definitions *************************************************/

typedef Int64_t gcov_type;

/**Information about counters for a single function
 *
 * This data is generated by gcc during compilation and doesn't change
 *  at run-time with the exception of the values array.
 */
struct gcov_ctr_info
{
  Uint32_t num;        /** number of counter values for this type */
  gcov_type *values;   /** array of counter values for this type */
};

/**
 * Profiling meta data per function
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time.
 *
 * Information about a single function.  This uses the trailing array
 * idiom. The number of counters is determined from the merge pointer
 * array in gcov_info.  The key is used to detect which of a set of
 * comdat functions was selected -- it points to the gcov_info object
 * of the object file containing the selected comdat function.
 */
struct gcov_fn_info
{
  const struct gcov_info *key;    /** comdat key */
  Uint32_t ident;                 /** unique ident of function */
  Uint32_t lineno_checksum;       /** function lineo_checksum */
  Uint32_t cfg_checksum;          /** function cfg checksum */
  struct gcov_ctr_info ctrs[0];   /** instrumented counters */
};

/** Profiling data per object file
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time with the exception of the next pointer. */
struct gcov_info
{
  Uint32_t version;                                     /** Gcov version (same as GCC version) */
  struct gcov_info *next;                               /** List head for a singly-linked list */
  Uint32_t stamp;                                       /** Uniquifying time stamp */
  const char *filename;                                 /** Name of the associated gcda data file */
  void (*merge[GCOV_COUNTERS])(gcov_type *, Uint32_t);  /** merge functions */
                                                        /** null for unused */
  Uint32_t n_functions;                                 /** number of instrumented functions */
  struct gcov_fn_info **functions;                      /** function information */
};

/***** Variables ********************************************************/

static struct gcov_info *gcov_info_head;

static Uint32_t hostIp;
static Uint32_t hostPort;

static Bool_t dumpRequired;

static Bool_t dumpComplete;

/***** Function Declarations ********************************************/

static d_Status_t CoverageDump(void);

static Uint32_t StoreGcovU64(Uint8_t * const buffer, const Uint32_t off, const Uint64_t v);

static Uint32_t StoreGcovU32(Uint8_t * const buffer, const Uint32_t off, const Uint32_t v);

static Int32_t CounterActive(struct gcov_info *info, Uint32_t type);

static Uint32_t ConvertToGcda(Uint8_t *buffer, struct gcov_info *info);

static void ReceiveCallback(const d_ETH_Ipv4Addr_t sourceAddr, 
                             const Uint16_t sourcePort, 
                             const Uint16_t destinationPort, 
                             const Uint8_t * const buffer, 
                             const Uint32_t length);

static void UdpTransmit(const Uint8_t * const pMessage,
                        const Uint32_t length);

/***** Function Definitions *********************************************/

/*********************************************************************//**
  <!-- d_COV_Initialise -->

  Initialise coverage measurement, open UDP listen socket
*************************************************************************/
d_Status_t         /** \return Initialisation status */
d_COV_Initialise
(
void
)
{
  d_Status_t status;

  status = d_ETH_UdpListen(d_ETH_PORT_COVERAGE, ReceiveCallback);
  if (status != d_STATUS_SUCCESS)
  {
    // gcov-jst 1 It is not possible to generate this error during bench testing.
    d_ERROR_Logger(d_STATUS_NOT_READY, d_ERROR_CRITICALITY_CRITICAL_SHUTDOWN, status, 0, 0, 0);
  }
  
  dumpRequired = d_FALSE;
  dumpComplete = d_FALSE;
  
  return status;
}

/*********************************************************************//**
  <!-- d_COV_Background -->

  Background process. Check for request to dump coverage data.
*************************************************************************/
void           /** \return None */
d_COV_Background
(
void
)
{
  d_Status_t status;
  if (dumpRequired == d_TRUE)
  {
    status = CoverageDump();
    dumpRequired = d_FALSE;
    if (status != d_STATUS_SUCCESS)
    {
      /* If dump failed than say complete anyway */
      // gcov-jst 1 It is not practical to generate this failure during bench testing.
      dumpComplete = d_TRUE;
    }
  }

  return;
}

/*********************************************************************//**
  <!-- d_COV_Complete -->

  Return a flag indicating if the coverage dump has been completed.
*************************************************************************/
Bool_t             /** \return Flag TRUE if coverage dump complete */
d_COV_Complete
(
void
)
{
  return dumpComplete;
}

/*********************************************************************//**
  <!-- d_COV_Continue -->

  Continue capturing data after a download.
*************************************************************************/
void
d_COV_Continue
(
void
)
{
  dumpComplete = d_FALSE;
  
  return;
}

/*********************************************************************//**
  <!-- __gcov_init -->

  Initialise the gcov data structures
  Is called by gcc-generated constructor code for each object file compiled
  with -fprofile-arcs.
*************************************************************************/
void                     /** \return None */
// clang-tidy-jst bugprone-reserved-identifier,cert-dcl37-c,cert-dcl51-cpp 1 Function required by GCOV library.
__gcov_init // cppcheck-suppress misra-c2012-8.4;  This function id used by the gcc-generated constructor code only. This does not present a risk.
(
struct gcov_info *info   /**< Profiling data set */
)
{
  info->next = gcov_info_head;
  gcov_info_head = info;
  
  return;
}

/*********************************************************************//**
  <!-- __gcov_exit -->

  Function required by GCOV library, but never executed'
*************************************************************************/
void           /** \return None */
// gcov-jst 8 Function required by GCOV library, but never executed.
// clang-tidy-jst bugprone-reserved-identifier,cert-dcl37-c,cert-dcl51-cpp 1 Function required by GCOV library.
 __gcov_exit // cppcheck-suppress misra-c2012-8.4;  This function id used by the gcc-generated constructor code only. This does not present a risk.
(
void
)
{
  return;
}

/*********************************************************************//**
  <!-- CoverageDump -->

  Dumps the coverage data to the host computer.
*************************************************************************/
static d_Status_t         /** \return d_STATUS_SUCCESS on success */
CoverageDump
(
void
)
{
  static Uint8_t dumpBuffer[BUFFER_SIZE];
  d_Status_t retval;
  struct gcov_info *tmp = gcov_info_head;
  Uint32_t size_tx;
  Uint8_t *pMessage;

  retval = d_STATUS_SUCCESS;
  while (tmp != NULL)
  {
    Uint32_t size = ConvertToGcda(NULL, tmp);
    if (size >= BUFFER_SIZE)
    {
      // gcov-jst 2 It is not possible to generate this error during bench testing.
      retval = d_STATUS_INSUFFICIENT_MEMORY;
    }

    if (retval == d_STATUS_SUCCESS)
    {
      (void)ConvertToGcda(&dumpBuffer[1], tmp);
      dumpBuffer[0] = 'W';

      /* Open file */
      UdpTransmit((const Uint8_t *)tmp->filename, strlen(tmp->filename));
      (void)d_TIMER_DelayMilliseconds(100);

      /* output coverage data in 1472 byte chunks */
      Uint32_t size_message = size + 1u;
      pMessage = &dumpBuffer[0];
      while (size_message > 0u)
      {
        size_tx = size_message;
        if (size_tx > d_ETH_MAX_UDP_PACKET_DATA)
        {
          size_tx = d_ETH_MAX_UDP_PACKET_DATA;
        }
        UdpTransmit(pMessage, size_tx);
        (void)d_TIMER_DelayMilliseconds(100);
        size_message = size_message - size_tx;
        // cppcheck-suppress misra-c2012-18.4;  Operation on Uint8_t pointer. Violation of 'Advisory' rule does not present a risk.
        pMessage = pMessage + size_tx;
        // cppcheck-suppress unsignedLessThanZero; Violation reported erroneously. The check is for an unsigned interger greater than zero
        if (size_message > 0u)
        {
          /* More data to send */
          size_message++; /* add one for another 'W' */
          pMessage--; /* back up for 'W' */
          *pMessage = 'W'; /* insert 'W' */
        }
      }

      /* close file */
      UdpTransmit((const Uint8_t *)"C", 1);
      (void)d_TIMER_DelayMilliseconds(100);

      tmp = tmp->next;
    }
  }
  
  if (retval == d_STATUS_SUCCESS)
  {
    dumpComplete = d_TRUE;
  }
  return retval;
}

/*********************************************************************//**
  <!-- StoreGcovU64 -->

  Store 64 bit number in gcov format to buffer.
************************************************************************/
static Uint32_t        /** \return The number of bytes stored */
StoreGcovU64
(
Uint8_t * const buffer,   /**< target buffer or NULL */
const Uint32_t off,    /**< offset into the buffer */
const Uint64_t value   /**< value to be stored */
)
{
  Uint32_t *data;
  if (buffer != NULL)
  {
    // cppcheck-suppress misra-c2012-11.3;  Operation on Uint8_t pointer. Violation of 'Advisory' rule does not present a risk.
    // cppcheck-suppress misra-c2012-18.4;  Operation on Uint8_t pointer. Violation of 'Advisory' rule does not present a risk.
    data = (Uint32_t *)(buffer + off);
    data[0] = (value & 0xffffffffUL);
    data[1] = (value >> 32u);
  }
  return sizeof(*data) * 2u;
}

/*********************************************************************//**
  <!-- StoreGcovU32 -->

  Store 32 bit number in gcov format to buffer.
*************************************************************************/
static Uint32_t        /** \return The number of bytes stored */
StoreGcovU32
(
Uint8_t * const buffer,   /**< target buffer or NULL */
const Uint32_t off,    /**< offset into the buffer */
const Uint32_t value   /**< value to be stored */
)
{
  Uint32_t *data;
  if (buffer != NULL)
  {
    // cppcheck-suppress misra-c2012-11.3;  Operation on Uint8_t pointer. Violation of 'Advisory' rule does not present a risk.
    // cppcheck-suppress misra-c2012-18.4;  Operation on Uint8_t pointer. Violation of 'Advisory' rule does not present a risk.
    data = (Uint32_t *)(buffer + off);
    *data = value;
  }
  return sizeof(*data);
}

/*********************************************************************//**
  <!-- CounterActive -->

  Determine whether a counter is active. Doesn't change at run-time.
*************************************************************************/
static Int32_t            /** \return 0 for not active */
CounterActive
(
struct gcov_info *info,   /**< GCOV information */
Uint32_t type             /**< Merge type */
)
{
  return (info->merge[type] != NULL) ? 1 : 0;
}

/*********************************************************************//**
  <!-- ConvertToGcda -->

  Convert profiling data set to gcda file format.
*************************************************************************/
static Uint32_t           /** \return The size of the gcda file */
ConvertToGcda
(
Uint8_t *buffer,          /**< the buffer to store file data or %NULL if no data should be stored */
struct gcov_info *info    /**< profiling data set to be converted */
)
{
  struct gcov_fn_info *functionInfo;
  Uint32_t functionIndex;
  Uint32_t counterIndex;
  Uint32_t counterValueIndex;
  Uint32_t pos = 0;

  /* File header. */
  pos += StoreGcovU32(buffer, pos, GCOV_DATA_MAGIC);
  pos += StoreGcovU32(buffer, pos, info->version);
  pos += StoreGcovU32(buffer, pos, info->stamp);

  for (functionIndex = 0; functionIndex < info->n_functions; functionIndex++) {
    functionInfo = info->functions[functionIndex];

    /* Function record. */
    pos += StoreGcovU32(buffer, pos, GCOV_TAG_FUNCTION);
    pos += StoreGcovU32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
    pos += StoreGcovU32(buffer, pos, functionInfo->ident);
    pos += StoreGcovU32(buffer, pos, functionInfo->lineno_checksum);
    pos += StoreGcovU32(buffer, pos, functionInfo->cfg_checksum);

    struct gcov_ctr_info *ci_ptr = functionInfo->ctrs;

    for (counterIndex = 0; counterIndex < (Uint32_t)GCOV_COUNTERS; counterIndex++) {
      if (CounterActive(info, counterIndex) == 0)
      {
        continue;
      }

      /* Counter record. */
      pos += StoreGcovU32(buffer, pos, GCOV_TAG_FOR_COUNTER(counterIndex));
      pos += StoreGcovU32(buffer, pos, ci_ptr->num * 2u);

      for (counterValueIndex = 0; counterValueIndex < ci_ptr->num; counterValueIndex++) {
        pos += StoreGcovU64(buffer, pos, ci_ptr->values[counterValueIndex]);
      }

      ci_ptr++;
    }
  }
  return pos;
}

/*********************************************************************//**
  <!-- UdpTransmit -->

  Send a UDP packet to the host computer
*************************************************************************/
static void                      /** \return None */
UdpTransmit
(
const Uint8_t * const pMessage,   /**< message to be sent */
const Uint32_t length            /**< length of message */
)
{
  (void)d_ETH_UdpSend(hostIp, hostPort, pMessage, length);

  return;
}

/*********************************************************************//**
  <!-- ReceiveCallback -->

  Callback function when UDP packet received.
*************************************************************************/
static void                          /** \return None */
ReceiveCallback
(
const d_ETH_Ipv4Addr_t sourceAddr,   /**< source IP address */
const Uint16_t sourcePort,           /**< source port number */
const Uint16_t destinationPort,      /**< destination port number */
const Uint8_t * const buffer,        /**< packet buffer */
const Uint32_t length                /**< data length */
)
{
  UNUSED_PARAMETER(destinationPort);
  UNUSED_PARAMETER(length);
  
  /* save the host IP address */
  hostIp = sourceAddr;
  hostPort = sourcePort;
  
  /* Check for coverage 'command' */
  if (buffer[0] == (Uint8_t)'C')
  {
    dumpRequired = d_TRUE;
  }

  return;
}


